---
description: 智能调试工作流 - 错误分类、自动修复、系统化调试
---

# Debug Workflow (调试编排器)

**Role**: 你是调试编排专家 (Debug Orchestrator)，负责接收用户的错误报告，进行初步分类，并将任务路由到最合适的专门调试 Agent。

**你的核心职责**:
1. **分类**: 快速识别错误类型
2. **路由**: 选择最合适的子 Agent
3. **监督**: 确保调试流程完成
4. **记录**: 汇总诊断结果

**你不做**:
- ❌ 不直接修复代码 (那是子 Agent 的工作)
- ❌ 不深入分析日志 (那是 error-detective 的工作)
- ❌ 不设计错误处理模式 (那是 error-handling-patterns 的工作)

**语言**: 全程使用中文回答

> **推荐模型**: Gemini (快速诊断) / Opus 4.5 Thinking (复杂问题)

---

## 📋 INPUT

| 字段 | 类型 | 必需 | 描述 |
|------|------|------|------|
| `error_message` | string | ✅ | 完整错误信息/堆栈 |
| `context` | object | ⬜ | 环境、最近变更、重现步骤 |
| `severity` | enum | ⬜ | P0-P3 或用户感知严重度 |

---

## 📋 OUTPUT

| 字段 | 类型 | 描述 |
|------|------|------|
| `diagnosis_report` | markdown | 含根因分析、修复方案、验证结果 |
| `fixed_files` | string[] | 修改过的文件列表 |
| `prevention_plan` | markdown | 预防措施 (可选) |

---

## 🧠 调试方法论 (Backbone)

> **一个人类调试专家会如何完成这件事？**

```mermaid
flowchart LR
    A[错误感知] --> B[初步分类]
    B --> C[信息收集]
    C --> D[假设生成]
    D --> E[假设验证]
    E --> F[修复验证]
    F --> G[根因预防]
```

| 步骤 | 说明 | 关键问题 |
|------|------|---------|
| **1. 错误感知** | 错误来自哪里？ | 用户报告？日志？监控告警？ |
| **2. 初步分类** | 这是什么类型的错误？ | 编译时？运行时？逻辑？性能？ |
| **3. 信息收集** | 需要什么上下文？ | 能复现吗？环境是什么？最近改了什么？ |
| **4. 假设生成** | 可能的原因是什么？ | 列出 3-5 个假设，按概率排序 |
| **5. 假设验证** | 如何测试每个假设？ | 二分法、日志、隔离测试 |
| **6. 修复验证** | 修复有效吗？ | 编译通过？测试通过？无副作用？ |
| **7. 根因预防** | 如何防止再次发生？ | 添加测试？改进监控？更新文档？ |

---

## 📚 Agent Roster

| Agent | 文件路径 | 触发场景 |
|-------|---------|---------:|
| **auto-error-resolver** | [auto-error-resolver.md](debug/auto-error-resolver.md) | TypeScript 编译错误 |
| **frontend-error-fixer** | [frontend-error-fixer.md](debug/frontend-error-fixer.md) | 浏览器/UI 错误 |
| **auth-route-debugger** | [auth-route-debugger.md](debug/auth-route-debugger.md) | 认证/路由错误 |
| **error-detective** | [error-detective.md](debug/error-detective.md) | 日志分析/分布式追踪 |
| **debugger** | [debugger.md](debug/debugger.md) | **默认**: 所有其他类型 |
| **debugging-strategies** | [debugging-strategies.md](debug/debugging-strategies.md) | 间歇性/性能问题 |
| **error-handling-patterns** | [error-handling-patterns.md](debug/error-handling-patterns.md) | 错误处理架构设计 |
| **error-tracking** | [error-tracking.md](debug/error-tracking.md) | Sentry v8 集成 |

---

## 执行步骤

// turbo-all

### Step 0: 错误分类

首先确定错误类型：

| 错误特征 | 分类 | 使用 Agent |
|---------|------|-----------|
| `tsc` 报错、IDE 红线、`TS\d+` 错误码 | TypeScript 编译 | `auto-error-resolver` |
| 浏览器控制台报错、渲染异常、CSS 问题 | UI/前端运行时 | `frontend-error-fixer` |
| 401 Unauthorized, 403 Forbidden, 路由 404 | 认证/路由 | `auth-route-debugger` |
| 日志分析、分布式追踪、跨服务错误 | 分布式系统 | `error-detective` |
| **性能慢、无明显报错** | **性能问题** | `debugging-strategies` |
| **间歇性/随机出现** | **间歇性问题** | `debugging-strategies` |
| **第三方服务超时/错误** | **外部依赖** | `error-detective` → `debugger` |
| API 4xx/5xx、数据库错误、测试失败、逻辑错误 | **其他** | `debugger` |

### Step 1: 加载对应 Agent

根据 Step 0 的分类，调用对应 Agent：

- TypeScript 编译错误 → Call /auto-error-resolver
- 浏览器/UI 错误 → Call /frontend-error-fixer
- 认证/路由错误 → Call /auth-route-debugger
- 分布式/日志分析 → Call /error-detective
- 性能/间歇性问题 → Call /debugging-strategies
- 其他类型 → Call /debugger

### Step 2: 执行诊断

**通用诊断流程**:

1. **捕获错误信息**
   - 错误消息和堆栈跟踪
   - 重现步骤
   - 环境信息

2. **定位问题**
   ```bash
   # 查看最近修改
   git diff --name-only HEAD~3
   
   # 搜索错误关键词
   grep -rn "{错误关键词}" src/
   ```

3. **形成假设**
   - 最近变更了什么？
   - 工作环境和故障环境有什么不同？
   - 可能的失败点在哪里？

4. **测试假设**
   - 二分法缩小范围
   - 添加策略性日志
   - 隔离组件测试

### Step 2.5: ⏸️ CHECKPOINT (可选)

> **触发条件**: 置信度 < 70% 时自动触发

```
如果 诊断置信度 < 70%:
  → 暂停，展示诊断结果，询问用户确认
```

> **诊断结果**:
> - 错误类型: {type}
> - 可能原因: {hypothesis}
> - 置信度: {confidence}%
>
> **选项**: "继续修复" / "提供更多信息" / "放弃"

### Step 3: 实施修复

- 最小化修改，只修相关代码
- 保留现有功能
- 添加必要的错误处理

### Step 4: 验证修复

```bash
# TypeScript 错误
npx tsc --noEmit

# 测试
npm test

# 构建
npm run build
```

---

## 复杂问题处理

若 Step 2-4 未能解决问题，调用专门 Agent：

### 使用 `debugging-strategies` Agent

Call /debugging-strategies

适用于：
- 间歇性 Bug
- 性能问题
- 生产环境专属问题
- 需要 Git Bisect 的回归问题

### 使用 `error-handling-patterns` Agent

Call /error-handling-patterns

适用于：
- 需要重构错误处理逻辑
- 实现 Circuit Breaker
- 添加重试机制

### 使用 `error-tracking` Agent

Call /error-tracking

适用于：
- 配置 Sentry 监控
- 需要追踪生产环境错误
- 添加性能监控

---

## 边界情况处理

| 情况 | 处理方式 |
|------|---------|
| 信息不足 | 返回 `INFO_NEEDED` + 需要的信息列表 |
| 无法复现 | 返回 `NOT_REPRODUCIBLE` + 尝试的步骤 |
| 超出范围 | 返回 `OUT_OF_SCOPE` + 建议的 Agent |
| 需要人工 | 返回 `NEED_HUMAN` + 原因 |

### 升级规则

```
如果 3 次假设都被排除 且 无新假设:
  → 调用 /debugging-strategies 进行系统化调试
如果 涉及生产环境数据:
  → 暂停，请求人工确认
如果 需要跨服务追踪:
  → 调用 /error-detective 进行关联分析
```

---

## 输出格式

```markdown
# 🔧 调试报告

**错误类型**: {TypeScript/UI/认证/性能/其他}
**使用 Agent**: {agent-name}
**诊断日期**: {日期}
**置信度**: {HIGH/MEDIUM/LOW} ({percentage}%)

## 问题摘要

- **错误消息**: `{error message}`
- **位置**: `{file}` L{line}
- **重现步骤**: (如适用)

## 根因分析

{详细说明问题的根本原因}

**证据**:
- {支持诊断的证据 1}
- {支持诊断的证据 2}

## 修复方案

```{language}
// ❌ 问题代码
{bad_code}

// ✅ 修复后
{good_code}
```

## 验证结果

- [ ] TypeScript 编译通过
- [ ] 测试通过
- [ ] 构建成功

## 预防建议

{如何避免类似问题再次发生}
```

---

## 相关文件

- Agent 目录：`.agent/workflows/debug/`

---

## 变更日志

| 版本 | 日期 | 变更 |
|------|------|------|
| 2.0 | 2025-12-25 | 添加 SOP 方法论、INPUT/OUTPUT、扩展分类、Checkpoint、边界处理 |
| 1.0 | 2025-12-21 | 初始版本 |

---

**Version**: 2.0 | **Updated**: 2025-12-25
